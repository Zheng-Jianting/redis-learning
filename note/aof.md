## AOF 持久化

除了 RDB 持久化功能之外，Redis 还提供了 AOF ( Append Only File ) 持久化功能，与 RDB 持久化通过保存数据库中的键值对来记录数据库状态不同，AOF 持久化是通过保存 Redis 服务器所执行的写命令来记录数据库状态的：

<img src="C:\Users\zjt\AppData\Roaming\Typora\typora-user-images\image-20220501182001504.png" alt="image-20220501182001504" style="zoom:80%;" />

有关 AOF 持久化的相关配置位于 redis.conf 配置文件中的 APPEND ONLY MODE 部分

**1. AOF 持久化的实现**

AOF 持久化功能的实现可以分为命令追加 ( append )、文件写入、文件同步 ( sync ) 三个步骤

**1.1 命令追加**

当 AOF 持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾：

```c
struct redisServer {
    // ...
    sds aof_buf; // AOF 缓冲区
    // ...
}
```

**1.2 AOF 文件的写入与同步**

Redis 的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像 serverCron 函数这样需要定时运行的函数

因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到 aof_buf 缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用 flushAppendOnlyFile 函数，考虑是否需要将 aof_buf 缓冲区中的内容写入和保存到 AOF 文件里面，这个过程可以用以下伪代码表示：

```python
def eventLoop():
    while True:
        # 处理文件事件, 接收命令请求以及发送命令回复
        # 处理命令请求时可能会有新内容被追加到 aof_buf 缓冲区中
        processFileEvents()
        
        # 处理时间事件
        processTimeEvents()
        
        # 考虑是否要将 aof_buf 中的内容写入和保存到 AOF 文件里面
        flushAppendOnlyFile()
```

flushAppendOnlyFile 函数执行以下两个步骤：

- WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件
- SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘

两个步骤都需要根据一定的条件来执行，而这些条件由 AOF 所使用的保存模式来决定：

| appendfsync 选项的值 |                flushAppendOnlyFile 函数的行为                |
| :------------------: | :----------------------------------------------------------: |
|        always        |      将 aof_buf 缓冲区中的所有内容写入并同步到 AOF 文件      |
|       everysec       | 将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，如果上次同步 AOF 文件的时间距离现在超过一秒钟，那么再次对 AOF 文件进行同步，并且这个同步操作是由一个线程专门负责执行的 |
|          no          | 将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，但并不对 AOF 文件进行同步，何时同步由操作系统来决定 |

注意：文件的写入并不意味着写入的内容真正同步到了磁盘

```tex
文件的写入和同步
为了提高文件的写入效率, 在现代操作系统中, 当用户调用 write 函数, 将一些数据写入到文件的时候, 操作系统通常会将写入的数据暂时保存在一个内存缓冲区里面, 等到缓冲区的空间被填满、或者超过了指定的时限之后, 才真正地将缓冲区中的数据写入到磁盘里面。
这种做法虽然提高了效率, 但也为写入数据带来了安全问题, 因为如果计算机发生停机, 那么保存在内存缓冲区里面的写入数据将会丢失。
为此, 系统提供了 fsync 和 fdatasync 两个同步函数, 它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面, 从而确保写入数据的安全性。
```

AOF 持久化的效率和安全性：

服务器配置 appendfsync 选项的值直接决定 AOF 持久化功能的效率和安全性：

- 当 appendfsync 的值为 always 时，服务器在每个事件循环都要将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，并且同步 AOF 文件，所以 always 的效率是 appendfsync 选项三个值当中最慢的一个，但从安全性来说，always 也是最安全的，因为即使出现故障停机，AOF 持久化也只会丢失一个事件循环中所产生的命令数据
- 当 appendfsync 的值为 everysec 时，服务器在每个事件循环都要将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，并且每隔一秒就要在子线程中对 AOF 文件进行一次同步。从效率上讲，everysec 模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据
- 当 appendfsync 的值为 no 时，服务器在每个事件循环都要将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，至于何时对 AOF 文件进行同步，则有操作系统控制。因为处于 no 模式下的 flushAppendOnlyFile 调用无须执行同步操作，所以该模式下的 AOF 文件写入速度总是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看，no 模式和 everysec 模式的效率类似，当出现故障停机时，使用 no 模式的服务器将丢失上次同步 AOF 文件之后的所以写命令数据

**2. AOF 文件的载入与数据还原**

因为 AOF 文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍 AOF 文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态

Redis 读取 AOF 文件并还原数据库状态的详细步骤如下：

- 创建一个不带网络连接的伪客户端 ( fake client )：因为 Redis 的命令只能在客户端上下文中执行，而载入 AOF 文件时所使用的命令直接来源于 AOF 文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行 AOF 文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样
- 从 AOF 文件中分析并读出一条写命令
- 使用伪客户端执行被读出的写命令
- 重复执行步骤 2 和步骤 3，直到 AOF 文件中的所有写命令都被处理完毕为止

<img src="C:\Users\zjt\AppData\Roaming\Typora\typora-user-images\image-20220501215500356.png" alt="image-20220501215500356" style="zoom:80%;" />

**3. AOF 重写**

因为 AOF 持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF 文件中的内容会越来越多，文件的体积会越来越大，如果不加以控制的话，体积过大的 AOF 文件很可能对 Redis 服务器、甚至整个宿主计算机造成影响，并且 AOF 文件的体积越大，使用 AOF 文件来进行数据还原所需的时间就越多

为了解决 AOF 文件体积膨胀的问题，Redis 提供了 AOF 文件重写 ( rewrite ) 功能，通过该功能，Redis 服务器可以创建一个新的 AOF 文件来替代现有的 AOF 文件，新旧两个 AOF 文件所保存的数据库状态相同，但新 AOF 文件不会包含任何浪费空间的冗余命令，所以新 AOF 文件的体积通常会比旧 AOF 文件的体积要小得多

**3.1 AOF 文件重写的实现**

虽然 Redis 将生成新 AOF 文件替换旧 AOF 文件的功能命名为 "AOF 文件重写"，但实际上，AOF 文件重写并不需要对现有的 AOF 文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的

**3.2 AOF 后台重写**